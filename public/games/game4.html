<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mini Game 4: Avoid the Fall</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        color: #fff;
        font-family: sans-serif;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div id="info">Avoid falling cubes for 30 seconds! Use left/right arrows to move.</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script>
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      camera.position.set(0, 6, 10);
      camera.lookAt(0, 0, 0);
      // lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(5, 10, 5);
      scene.add(dir);
      // ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(20, 4),
        new THREE.MeshStandardMaterial({ color: 0x222222 })
      );
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);
      // player box
      const playerGeo = new THREE.BoxGeometry(1, 1, 1);
      const playerMat = new THREE.MeshStandardMaterial({ color: 0x00aaff });
      const player = new THREE.Mesh(playerGeo, playerMat);
      player.position.set(0, 0.5, 0);
      scene.add(player);
      // cubes list
      const cubes = [];
      // spawn cubes
      function spawnCube() {
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshStandardMaterial({ color: 0xff5050 });
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set((Math.random() - 0.5) * 18, 8, 0);
        cubes.push(cube);
        scene.add(cube);
      }
      // spawn interval
      let spawnTimer = 0;
      const spawnInterval = 0.8; // seconds
      // movement
      const keys = {};
      window.addEventListener("keydown", (e) => (keys[e.key] = true));
      window.addEventListener("keyup", (e) => (keys[e.key] = false));
      let startTime = performance.now();
      let gameOver = false;
      function animate(time) {
        const delta = (time - (animate.lastTime || time)) / 1000;
        animate.lastTime = time;
        requestAnimationFrame(animate);
        if (!gameOver) {
          // spawn cubes periodically
          spawnTimer += delta;
          if (spawnTimer >= spawnInterval) {
            spawnCube();
            spawnTimer = 0;
          }
          // move cubes
          for (let i = cubes.length - 1; i >= 0; i--) {
            const c = cubes[i];
            c.position.y -= delta * 4;
            if (c.position.y < -1) {
              scene.remove(c);
              cubes.splice(i, 1);
            }
            // collision with player
            if (c.position.distanceTo(player.position) < 1) {
              gameOver = true;
              document.getElementById("info").innerText = "Game over! You were hit.";
              break;
            }
          }
          // player movement
          const speed = 5 * delta;
          if (keys["ArrowLeft"]) player.position.x -= speed;
          if (keys["ArrowRight"]) player.position.x += speed;
          player.position.x = THREE.MathUtils.clamp(player.position.x, -9, 9);
          // check win
          const elapsed = (time - startTime) / 1000;
          if (!gameOver && elapsed >= 30) {
            gameOver = true;
            document.getElementById("info").innerText =
              "Congratulations! You survived and win.";
          }
        }
        renderer.render(scene, camera);
      }
      animate();
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>