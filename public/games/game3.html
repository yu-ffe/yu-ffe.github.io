<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mini Game 3: Memory Match</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        color: #fff;
        font-family: sans-serif;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div id="info">Find all matching pairs.</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script>
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 4, 6);
      camera.lookAt(0, 0, 0);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      // lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 0.5);
      dir.position.set(3, 5, 3);
      scene.add(dir);
      // table plane
      const table = new THREE.Mesh(
        new THREE.PlaneGeometry(6, 4),
        new THREE.MeshStandardMaterial({ color: 0x333333 })
      );
      table.rotation.x = -Math.PI / 2;
      scene.add(table);
      // colors (3 pairs)
      const colors = [0xff6666, 0x66ff66, 0x6666ff];
      // create cards
      const cards = [];
      const positions = [];
      const rows = 2;
      const cols = 3;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          positions.push([
            (c - (cols - 1) / 2) * 2,
            0.5,
            (r - (rows - 1) / 2) * 2
          ]);
        }
      }
      // assign color indices randomly
      const colorIndices = [0, 0, 1, 1, 2, 2].sort(() => 0.5 - Math.random());
      const backMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
      for (let i = 0; i < 6; i++) {
        const geo = new THREE.BoxGeometry(1, 0.2, 1.5);
        const mat = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const cube = new THREE.Mesh(geo, mat);
        const pos = positions[i];
        cube.position.set(pos[0], pos[1], pos[2]);
        cube.userData = {
          colorIndex: colorIndices[i],
          revealed: false,
          matched: false,
          frontMaterial: new THREE.MeshStandardMaterial({ color: colors[colorIndices[i]] }),
        };
        cards.push(cube);
        scene.add(cube);
      }
      // raycaster for click
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let selected = [];
      let matches = 0;
      let allowClick = true;
      function onClick(event) {
        if (!allowClick) return;
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(cards);
        if (intersects.length > 0) {
          const obj = intersects[0].object;
          const data = obj.userData;
          if (data.matched || data.revealed) return;
          // reveal
          obj.material = data.frontMaterial;
          data.revealed = true;
          selected.push(obj);
          if (selected.length === 2) {
            allowClick = false;
            const [a, b] = selected;
            if (a.userData.colorIndex === b.userData.colorIndex) {
              // match
              a.userData.matched = true;
              b.userData.matched = true;
              matches++;
              selected = [];
              allowClick = true;
              if (matches === 3) {
                document.getElementById("info").innerText =
                  "You matched all pairs! You win.";
              }
            } else {
              // not match: flip back after delay
              setTimeout(() => {
                a.material = backMaterial;
                b.material = backMaterial;
                a.userData.revealed = false;
                b.userData.revealed = false;
                selected = [];
                allowClick = true;
              }, 800);
            }
          }
        }
      }
      window.addEventListener("click", onClick);
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
      animate();
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>