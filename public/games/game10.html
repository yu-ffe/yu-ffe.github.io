<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mini Game 10: Breakout</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        color: #fff;
        font-family: sans-serif;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div id="info">Break all the bricks! Use left/right arrows to move.</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script>
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 6, 12);
      camera.lookAt(0, 0, 0);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(5, 10, 5);
      scene.add(dir);
      // boundaries
      const boundary = { left: -5, right: 5, top: 4, bottom: -4 };
      // paddle
      const paddle = new THREE.Mesh(
        new THREE.BoxGeometry(2, 0.5, 0.5),
        new THREE.MeshStandardMaterial({ color: 0x00aa00 })
      );
      paddle.position.set(0, 0.25, boundary.bottom + 0.5);
      scene.add(paddle);
      // ball
      const ball = new THREE.Mesh(
        new THREE.SphereGeometry(0.25, 32, 32),
        new THREE.MeshStandardMaterial({ color: 0xff4444 })
      );
      ball.position.set(0, 0.3, 0);
      ball.userData.velocity = new THREE.Vector3(2, 0, 3);
      scene.add(ball);
      // bricks
      const bricks = [];
      const rows = 3;
      const cols = 7;
      const brickW = 1;
      const brickH = 0.5;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const brick = new THREE.Mesh(
            new THREE.BoxGeometry(brickW, 0.5, 0.5),
            new THREE.MeshStandardMaterial({ color: 0x4477ff })
          );
          brick.position.set(
            boundary.left + brickW / 2 + c * (brickW + 0.1) + 1,
            0.25,
            boundary.top - 1 - r * 0.6
          );
          scene.add(brick);
          bricks.push(brick);
        }
      }
      let lives = 3;
      let won = false;
      const keys = {};
      window.addEventListener("keydown", (e) => (keys[e.key] = true));
      window.addEventListener("keyup", (e) => (keys[e.key] = false));
      function animate(time) {
        requestAnimationFrame(animate);
        const delta = (time - (animate.last || time)) / 1000;
        animate.last = time;
        if (!won && lives > 0) {
          // move paddle
          const paddleSpeed = 6 * delta;
          if (keys["ArrowLeft"]) paddle.position.x -= paddleSpeed;
          if (keys["ArrowRight"]) paddle.position.x += paddleSpeed;
          paddle.position.x = THREE.MathUtils.clamp(
            paddle.position.x,
            boundary.left + paddle.geometry.parameters.width / 2,
            boundary.right - paddle.geometry.parameters.width / 2
          );
          // move ball
          ball.position.x += ball.userData.velocity.x * delta;
          ball.position.z += ball.userData.velocity.z * delta;
          // wall collisions
          if (
            ball.position.x < boundary.left + 0.25 ||
            ball.position.x > boundary.right - 0.25
          ) {
            ball.userData.velocity.x *= -1;
          }
          if (ball.position.z > boundary.top - 0.25) {
            ball.userData.velocity.z *= -1;
          }
          // paddle collision
          if (
            ball.position.z < paddle.position.z + 0.25 &&
            Math.abs(ball.position.x - paddle.position.x) < 1.1 &&
            ball.userData.velocity.z < 0
          ) {
            ball.userData.velocity.z *= -1;
          }
          // brick collisions
          for (let i = bricks.length - 1; i >= 0; i--) {
            const b = bricks[i];
            if (
              Math.abs(ball.position.x - b.position.x) < brickW / 2 + 0.25 &&
              Math.abs(ball.position.z - b.position.z) < 0.25 + 0.25
            ) {
              bricks.splice(i, 1);
              scene.remove(b);
              ball.userData.velocity.z *= -1;
              if (bricks.length === 0) {
                won = true;
                document.getElementById("info").innerText = "All bricks destroyed! You win.";
              }
              break;
            }
          }
          // miss
          if (ball.position.z < boundary.bottom - 0.5) {
            lives--;
            if (lives === 0) {
              document.getElementById("info").innerText = "Game over! You ran out of lives.";
            } else {
              ball.position.set(0, 0.3, 0);
              ball.userData.velocity.x = (Math.random() > 0.5 ? 1 : -1) * 2;
              ball.userData.velocity.z = 3;
              document.getElementById("info").innerText =
                `Lives remaining: ${lives}. Bricks left: ${bricks.length}`;
            }
          }
        }
        renderer.render(scene, camera);
      }
      animate();
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>